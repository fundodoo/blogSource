---
title: Zookeeper技术内幕
categories:
  - Zookeeper
top: false
date: 2020-04-01 13:54:21
tags: 
- Zookeeper
keywords:
description: 
---

## 数据模型znode
> `zk`数据存储结构与标准的unix文件系统非常相似，都是在*根节点*下挂很多*子节点*。`zk`中没有引入传统文件系统中目录与文件的概念，而是使用了称为`znode`的数据节点概念。`znode`是`zk`中数据的**最小单元**，每个`znode`上都可以**保存数据**和**挂载子节点**，形成一个*树形化*命名空间。

![znode](/images/znode.png)

### 节点类型
-  **持久节点**：zk中最常见的节点，节点一旦被创建，只要不删除，其就会一直存在于zk中。
- **持久*顺序*节点**：一个**父节点**可以为其**直接子节点**维护一份顺序，用于记录子节点创建的先后顺序。在创建子节点时，会自动在指定的节点名称后添加数字后缀，作为该节点的完整名称。序号由`10`位数字组成，从0开始计数。
-  **临时节点**：临时节点的**生命周期**与客户端的**会话**绑定在一起，会话消失则该节点也会消失。临时节点只能作为叶子节点，**不能**创建子节点。
-  **临时*顺序*节点**：添加了*创建序号*的临时节点

### 节点状态
- `cZxid`：**Created Zxid**，表示当前`znode`被**创建**时的 ***事务ID***
- `ctime`：**Created Tiem**，表示当前`znode`被**创建**的 ***时间***
- `mZxid`：**Modified Zxid**，表示当前`znode`**最后**一次被**修改**时的 ***事务ID***
- `mtime`：**Modified Time**，表示该`znode`**最后**一次被**修改**的 ***时间***。
- `pZxid`：表示当前`znode`的**子节点列表**最后一次被修改时的**事物ID**。（只能是**子节点列表变更**了才会引起pZxid的变更，子节点**内容**的修改**不会**影响`pZxid`）
- `cversion`：**Children Version**，表示**子节点的版本号**，该版本号用于充当乐观锁
- `dataVersion`：表示当前`znode`**数据的版本号**，该版本号用于充当乐观锁
- `aclVersion`：表示当前`znode`的权限**ACL的版本号**，该版本号用于充当乐观锁。
- `ephemeralOwner`：若当前`znode`为**持久**节点，则其值为`0`；若为**临时**节点，则其值为创建该节点的会话的`SessionID`。会话**断开**后会根据`SessionID`来**删除**相关**临时节点**
- `dataLength`：当前`znode`中存放的**数据的长度**
- `numChildren`：当前`znode`所包含的**子节点**的 *个数*。

## 会话
> 客户端和服务端之间的任何操作都与会话有关
> Zookeeper客户端启动时，首先会与zk服务器建立一个TCP长连接，连接一旦建立，客户端会话的生命周期也就开始了。

### 会话状态
- `CONNECTING`：连接中。Client要创建一个连接，首先会在*本地* **创建一个对象**，用于表示其所连接上的Server。从zk对象被创建开始，会话状态就进入了CONNECTING，同时Client会从Server服务列表中通过轮询方式逐个尝试连接，直到连接成功。`注意`：在轮询前，其首先会将列表进行**随机打散**，然后再在打散的基础上进行**轮询**。
- `CONNECTED`：已连接。连接成功后，该连接的各种**临时性数据**会被**初始化到zk对象**中
- `CLOSED`：已关闭。连接关闭后，这个代表server的`zk对象`会被**删除**

### 会话连接超时管理---客户端维护
> *客户端*所发起的服务端连接时间记录，是从**客户端**当前会话**第一次**发起服务端连接的时间开始计时。

### 会话空闲超时管理---服务端维护
> *服务端*为每一个客户端的会话都记录上一次交互后空闲的时长，即从上一次交互结束后就开始会话空闲超时的时间计时。一旦空闲时长超时，服务端就会将该会话的SessionId从服务端清除。这也就是为什么客户端在空闲时需要向服务端发送心跳，就是为了维护这个长连接会话。服务器是通过空闲超时来判断会话是否发生中断的。
> 服务端对于会话空闲超时的管理，采用了一种特殊的方式---**分桶策略**

- 分桶策略：将空闲超时时间相近的会话放到同一个桶中进行管理，以减少管理的复杂度。在检查超时的时候，只需要检查桶中剩下的会话即可，因为没有超时的会话已经被移出了桶，而桶中存在的会话就是超时的会话。zk对于会话空闲的**超时**管理并**非精确**的管理，即并非是一超时马上就执行相关的超时操作。
- 分桶依据：从以下公式可知，一个桶的大小为ExpirationInterval时间。只要ExpirationTime落入到同一个桶中，系统就会对其中的会话超时进行统一管理。
    > ExpirationTime = CurrentTime + SessionTimeout
    > BucketTime = (ExpirationTime/ExpirationInterval + 1)*ExpirationInterval


### 会话连接事件
> 客户端和服务端的长连接失效后，客户端将进行重连。在重连的过程中客户端会产生三种会话连接事件
- `CONNECTION_LOSS`: **连接丢失**。由于网络抖动等原因造成客户端长时间无法收到服务端的心跳回复，客户端就会引发**连接丢失事件**。该事件会触发当前客户端重连服务端，直到连接成功或连接超时。
- `SESSION_MOVED`: **会话转移**。当发生连接丢失事件后，若客户端重新连接成功，但是此时连接成功的zk主机不是上一次连接的zk主机，此时服务端就会引发**会话转移异常**，而客户端就会引发**会话转移事件**，该事件会触发当前客户端使用第二次连接上的zk主机的地址与Server进行交互。
- `SESSION_EXPIRED`: **会话失效**。若服务端发现某客户端会话空闲时间超时，那么服务器就会将该客户端会话进行清除。对于客户端来说，其长时间没有收到服务端的心跳回复，就会引发**连接丢失事件**，然后重新连接，直到连接成功或超时。但在会话已经从服务端清除，而重新连接又未超时的一个短暂的事件缝隙中，客户端与服务端连接成功了，此时客户端就会引发**会话失效事件**。该事件会触发客户端取消该连接，并使客户端重新实例化zk对象，即使用新的SessionId进行重连。

## ACL
> ACL全称为`Access Control List`(访问控制列表)，是一种细粒度的权限管理策略，可以针对任意用户与组进行细粒度的权限控制。zk利用`ACL`控制`znode`节点的访问权限，如znode数据读写、znode创建、znode删除、读取子节点列表、设置节点权限等。
> Zookeeper的ACL分为三个维度：`授权策略scheme`、`授权对象id`、`用户权限permission`，子znode **不会** `继承`父znode的权限。

### 授权策略scheme
> 授权策略用于确定权限验证过程中使用的检测策略，在zk中常用的策略有

- IP：根绝`IP`地址进行权限验证
- digest：根据用`户名和密码`进行验证
- world：对所有用户`不`做任何验证
- super：`超级用户`可以对任意`znode`进行`任意操作`。这种模式打开客户端的方式都与正常方式的不同，需要在打开客户端时`添加`一个`系统属性`。

### 授权对象id
> 授权对象指的是权限赋予的用户。不同的授权策略具有不同类型的授权对象，下面是各个授权模式对应的授权对象id

- ip： 授权对象是`ip`地址
- digest：授权对象是`用户名 + 密码`
- world：其授权对象只有一个，即`anyone`
- Super：与digest相同，即授权对象为`用户名 + 密码`

### 权限permission
> 通过验证的用户可以对znode执行的操作，共有5种权限，而且zk支持自定义权限。

- c：`Create`，允许授权对象在当前节点下**创建子节点**。
- d：`Delete`，允许授权对象`删除`**当前**节点。
- r：`Read`，允许授权对象`读取` **当前**节点的*数据内容*，及**子节点列表**。
- w：`Write`，允许授权对象`修改` **当前**节点的数据内容，及**子节点列表**。
- a：`Acl`，允许授权对象对当前节点进行`ACL`相关的设置。

## Watcher机制
> zk通过`Watcher`机制实现了`发布/订阅`模式

### watcher 工作原理
1. `ZKclient`生成`watcher`对象，并存放到`WatchManager`
2. `ZKclient`向`ZKServer` **注册** `watcher`
3. `ZKServer` **发生** `watcher` *事件*
4. `ZKServer` 向 `ZKClient` 发送相应**事件**通知
5. `ZKClient`根据通知从`WatchManager`中找到相应的`watcher`对象
6. `ZKClient`的`watcher`对象*执行*相应**回调** 

### watcher 事件


### watcher 特性
-  **一次性**：一旦一个`watcher`被触发，zk就会将其从*客户端*的`WatcherManager`中*删除*，*服务端*中也会**删除**该`watcher`。`zk`的`watcher`机制**不适合**监听变化*非常频繁*的场景。
-  **串行性**：对于*同一个节点*的**相同**事件类型的`watcher`回调方法的执行是*串行*的。
-  **轻量级**：真正传递给`Server`的是一个*简易版*的`watcher`。回调逻辑存放在客户端，没有在服务端。
